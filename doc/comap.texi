\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename comap.info
@settitle CoMap Manual 1.3.0
@afourpaper
@c %**end of header

@include version.texi

@copying
This is the manual of CoMap, version @value{VERSION}, @value{UPDATED}.

Copyright @copyright{} 2006, 2007, 2008 Julien Dutheil
@end copying

@titlepage
@title CoMap Manual
@author Julien Dutheil
@author @email{julien.dutheil@@univ-montp2.fr}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1fill1
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top CoMap Manual

@insertcopying
@end ifnottex

@menu
* Introduction::                Introducing the CoMap program and this manual.                
* Data::                        How to import data into CoMap, file format, etc.                        
* Model::                       Markov model specification.                     
* Estimation::                  How to estimate parameters before an analysis.                 
* Mapping::                     Compute the substitution mapping.                   
* Pairwise::                    Performing the pairwise analysis of Dutheil et al. (2005).                 
* Clustering::                  Performing the clustering analysis of Dutheil et al. (2007).              
* Candidates::                  Candidate groups analysis (under development)
* Pvalue::                      Using the R scripts to compute p-values.                            
@end menu

@c ------------------------------------------------------------------------------------------------------------------

@node Introduction, Data, Top, Top
@chapter Introduction

CoMap performs two kinds of tasks:
@table @emph
@item (Weighted) Probabilistic substitution mapping
Compute all (weighted) number of subsitutions occuring on each branch of a tree,
for each site of an alignment.

@item Co-evolution analysis
Using the substitution mapping, look for significantly groups of sites
departing the null hypothesis of independance.
Two kind of analyses are provided: a pairwise analysis, presented in
Dutheil et al. (2005), and a clustering analysis in Dutheil ang Galtier (2007).
In both cases, a parametric bootstrap approach is used to evaluate the
significance of groups. Simulation results are written to separate
files, a statistics software like R is required to look for the
significancy.
For the clustering analysis, we provide R script to perform theses
computations.
No preliminary knowledge of the R language is required, although it is recommanded.

@end table

CoMap is a command line program, written in C++ using the Bio++
libraries. It uses the Bio++ syntaxe, so that arguments may be passed
as parameter=value options, either directly to the command line or
using an option file:
@cartouche
@example
comap parameter1=value1 parameter2=value2 ... parameterN=valueN
@end example
@end cartouche
or
@cartouche
@example
comap param=option_file.
@end example
@end cartouche
Option files are a list of parameter=value lines, with only one
parameter per line. Extra-space may however be included between
parameter name, equal sign and value:
@cartouche
@example
first_parameter   = value1
second_parameter  = value2
@end example
@end cartouche
Comment may also be included, in either script format
@cartouche
@example
# This is a comment
@end example
@end cartouche
or C format
@cartouche
@example
/* This is a comment
*/
@end example
@end cartouche
or C++ format
@cartouche
@example
// This is a comment
@end example
@end cartouche
Command line and file options may be combined:
@cartouche
@example
comap param=option_file parameterX=valueX
@end example
@end cartouche
In case of parameterX is specified in both option file and command
line, the command line value will be used.
This allows to run CoMap several time by changing a single option,
like the kind of mapping for instance.

The next chapters describes the whole set of options available in CoMap.
The type of parameter value expected is defined as:
@table @command
@item [chars]
A character chain

@item [path]
A file path, may be absolute or related to the current directory

@item [int]
An integer

@item [int], [int>0], [int>=0], [int[2,10]]
An integer, a positive integer, a positive non-null integet, an
integer folling between 2 and 10

@item [real], [real>0], etc
A real number, a positive real number, etc.

@item [boolean]
A boolean value, may be one of 'yes', 'no', 'true' or 'false'

@item [xxx|xxx|xxx]
A set of allowed values

@item list[type]
A list of values of specified type, separated by comas.

@end table

From version 1.2, CoMap can use Bio++ macro system.
This possible to recall anywhere the value of an option by using $(parameter).
@cartouche
@example
model.name=JTT92
rat_distribution=gamma
output.tree = mydata$(model)$(rate_distribution).dnd
@end example
@end cartouche
You can use this system to define global variables:
@cartouche
@example
data=LSU
sequence.file=$(data).fasta
input.tree=$(data).dnd
output.infos=$(data).infos
@end example
@end cartouche
 
@c ------------------------------------------------------------------------------------------------------------------

@node Data, Model, Introduction, Top
@chapter Data loading

@table @command
@item alphabet = [DNA|RNA|Protein]
The alphabet to use when reading sequence.

@item sequence.file=[path]
The sequence file to use (sequences must be aligned!)

@item sequence.format = [Mase|Fasta|Phylip|Clustal|DCSE]
The alignment file format.

@item sequence.format_mase.site_selection = [chars]
Meaningful only for mase format.
Specify a name for a site set to use.

@item sequence.format_phylip.order = [interleaved|sequential]
Meaningful only for phylip format.
Tells if sequences are interleave or sequential format.

@item sequence.format_phylip.ext = [classic|extended]
Meaningful only for phylip format.
The @option{classic} option corresponds to old phylip format, with
names up to ten characters.
The @option{extended} option corresponds to the behaviour of PAML,
which allows sequence name of any size, separated from the sequence
with at least two spaces. 

@item sequence.sites_to_use = [all|nogap|complete]
Tells wich sites to use.
The @option{nogap} option removes all sites containing at least one
gap, and the @option{complete} option removes all sites containing at
least one gap or one generic character, as 'X' for instance.

@item sequence.max_gap_allowed=101%
Only works when the @option{all} option is selected.
specify the maximum amount of gap allowed by site, given as a number
of sequence or a percentage.
Sites not succeeding the criterion will not be included in the analysis.

@item tree.file = [path]
The phylogenetic tree file to use.
Branch lengths are optional.
Only newick format is supported for now.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Model, Estimation, Data, Top
@chapter Model specification

@section Substitution model

@table @command

@item model.name = [JCnuc|K80|T92|HKY85|F84|TN93|GTR|JCprot|DSO78|JTT92|empirical]
Specify the substitution model to use.
For proteins, the DCmutt method is used for JTT92 and DSO78.
You can use the @option{empirical} option to specify another model, as
a text file in PAML format.

@item model.kappa=[real>0]
Initial value or fixed value for parameter kappa
(transition/transversion ratio) in models K80, T92, HKY85 and F84

@item model.kappa1=[real>0]
Initial value or fixed value for parameter kappa1 in model TN93

@item model.kappa2=[real>0]
Initial value or fixed value for parameter kappa2 in model TN93

@item model.theta=[real]0,1[]
Initial value or fixed value for parameter theta (GC content) in model
T92, HKY85, F84, TN93 and GTR.

@item model.theta1 = [real]0,1[]
Proportion of G / (G + C) in models
HKY85, F84, TN93 and GTR

@item model.theta2 = [real]0,1[]
Proportion of A / (A + T/U) in models
HKY85, F84, TN93 and GTR

@item model.a,b,c,d,e = [real>0]
Parameters of the GTR model

@item model.use_observed_freq = [boolean]
Tell if we have to use observed frequencies as parameter values (for @option{theta}, @option{theta1}, @option{theta2}, etc).
For proteins, this is equivalent to the -F model family.

@item model_empirical.file = [path]
Meaningful only if the @option{empirical} option is selected.
Specify the path where to find the model (in PAML format).

@end table



@section Non-homogeneous models

You can specify a wide range of non-homogeneous models.
The novelty from the homogeenous case is that the likelihood depends on the position of the root.
Root frequencies are hence distinct parameters:

@table @command

@item nonhomogeneous.root_freq=[balanced|observed|init|balancedGC|observedGC|initGC]
The @option{balanced} option set all the frequencies to 1/size of the alphabet.
The @option{balancedGC} option is for nucleotides only, and set the G content equal to the C content equal to 0.5.
The @option{observed} option set frequencies equal to their values in the data set,, and @option{observedGC} does the same for the GC content.
The @option{init} and @option{initGC} options allows you to set the values of the frequencies by hand.

@item model.ancA, ancC,..., ancA, ancR, ancN, ..., ancTheta
Initial values of ancestral frequencies if the @option{init} or @option{initGC} have been specified.

@end table

@table @command

@item nonhomogeneous = [no|one_per_branch|general]
Homogeneous model, Galtier & Gouy 1997 model family or the general case.

@end table

@subsection One-per-branch non-homogeneous models

This option share the same parameters as the homogeneous case, since the same kind of model is used for each branch. The additional options are the following:
@table @command
@item nonhomogeneous_one_per_branch.shared_parameters = [list]
List the names of the parameters that are shared by all branches.
In Galtier & Gouy model, that would be model.kappa, since only the theta parameter is branch-specific.

@end table

@subsection General non-homogeneous models

Bio++ provides a general syntaxe to specify almost any non-homogeneous model.

@table @command

@item nonhomogeneous.number_of_models
Set the number of distinct models to use.

@end table

You now have to configure each model individually, using the syntaxe introduced for the homogeneous case, excepted that model will be numbered, for instance:

@example
model1.name = T92
model1.theta = 0.39
model1.kappa = 2.79
@end example

The additional option is available to attach the model to branches in the tree, specified by the id of the upper node in the tree:

@table @command

@item model1.nodes_id = 1,5,10:15,19
Specify the ids of the nodes to which the node is attached.
Id ranges can be specified using the @option{begin:end} syntaxe.

@end table

You can also make a given model share parameters with another one by writting for instance:
@example
model2.name = T92
model2.theta = 0.39
model2.kappa = model1.kappa
@end example

Finally, you may find useful the following options:

@table @command

@item output.tags.file = [[path]|none]
A tree file in newick format, with node ids instead of bootstrap
values.
The node ids are the same as in the the vector file. 

@item output.tags.translation = [[path]|none]
Write a file whith the correspondance between leaf names and ids.

@end table



@section Rate across site distribution

@table @command

@item rate_distribution = [constant|gamma@{+invariant@}]
Specify the rate across sites distribution, as constant or gamma, optionally with an invariant class.

@item rate_distribution.alpha = [real>0]
The gamma distribution's shape parameter

@item rate_distribution.classes_number = [int>=2]
The number of classes to use in discretization (not including the invariant class if any)

@item rate_distribution.p = [real[0,1]]
Proportion of invariant sites

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Estimation, Mapping, Model, Top
@chapter Numerical parameters estimation

CoMap can (re-)estimate numerical parameters for you before any
analysis.
These parameters include
@itemize @bullet
@item
Branch lengths

@item
Entries of the substitution matrices, included base frequencies.
values)

@item
Parameters of the rate distribution (shape parameter of the gamma law, proportion of invariant sites).

@end itemize

@table @command

@item optimization = [boolean]
Tells if numerical  parameters should be estimated.
Topology estimation is not supported.

@item optimization.method=[DB|fullD]
The optimization method to use.
DB (default) uses derivatives-based optimization for branch lengths + Brent for
other parameters, and the fullD options uses derivatives for all parameters, with numerical derivatives for non-branch lengths parameters.

@item optimization_DB.nstep=[int>=1]
Number of progressive steps to perform during optimization.
If nstep=3 and precision=E-6, a first optimization with precision =
E-2, will be performed, then a round with precision set to E-4 and
finally precision will be set to E-6. This approcah generally saves
significant computation time.

@item optimization.method.derivatives = [newton|gradient]
Derivatives-based algorithm to use.
The Newton algorithm uses derivatives up to the second order, and is the recommanded choice.
The gradient algortihm uses only first order derivatives and can also be used.

@item optimization.final = [powell|simplex]
Optinal final optimization step, useful if numerical derivatives are to be used.
Leave the field empty in order to skip this step.

@item optimization.profiler = [[path]|std]|none
A file where to dump optimization steps (a file path or std for
standard output or none for no output).

@item optimization.message_handler = [[path]|std|none]
A file where to dump warning messages.

@item optimization.max_number_f_eval = [int<0]
The maximum number of likelihood evaluation to perform.

@item optimization.ignore_parameter = list[float[0,1]
A list of parameters to ignore during the estimation process.

@item optimization.tolerance = [float>0]
The precision on the log-likelihood to reach.

@item output.tree.file = [[path]|none]
File path where to write the optimized tree.

@item output.infos = [[path]|none]
A text file containing several statistics for each site in the
alignment.
These statistics include posterior rate, rate class with maximum
posterior probability and whether the site is conserved or not.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Mapping, Pairwise, Estimation, Top
@chapter Substitution mapping

Options in this chapter are for substitution vectors computation.

@table @command

@item input.vectors.file = [[path]|none]
Restart an analysis by specifying the already computed vectors.
Otherwise, compute vectors using the following options.

@item nijt = [laplace|simple|aadist]
The kind of mapping to perform.
@option{laplace} option perform exact mapping, as in Dutheil et
al. (2005).
@option{simple} performs a naive mapping, as in Tufféry and Darlu
(2000).
@option{aadist} performs a weighted mapping, as in Dutheil and Galtier
(2007). Currently available only for proteins.

@item nijt_aadist.type = [grantham|miyata|grantham.volume|grantham.polarity|charge|klein.charge|user1|user2]
Specify the type of weight to use.
The @option{user1} option is for computing a simple distance from a AAIndex1 file, @option{user2} uses a AAIndex2 distance file.

@item nijt_aadist.type_user1.file = [path]
File path toward a AAIndex1 file.
Used only if @option{nijt_aadist.type=user1}.

@item nijt_aadist.type_user2.file = [path]
File path toward a AAIndex2 file.
Used only if @option{nijt_aadist.type=user2}.

@item nijt_aadist.sym = [boolean]
Tell if symetric matrices must be used.
This option should be set to "no" for testing compensation.

@item output.vectors.file = [[path]|none]
Where to write the substitution mapping.

@end table

@section Optional commands

@table @command
@item nijt_laplace.trunc = [int>0]
Where to trunc the series when estimating exact number of
substitutions. A value of 10 should be fine.

@item nijt.average = [boolean]
Tell if mapping should be averaged over all ancestral states
(probabilistic mapping).
Otherwise use ancestral states reconstruction (naive mapping).
In most case, you should leave the default value (yes).
NB: only marginal ancestral state reconstruction is implemented. 

@item nijt.joint = [boolean]
Tell if joint probabilities are to be use, otherwise us emarginal
probabilities.
This option is for method comparisons, a 'yes' value is suitable in
most cases.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Pairwise, Clustering, Mapping, Top
@chapter Pairwise analysis

@table @command

@item analysis = pairwise
Use this option for performing a pairwise analysis.
If another option or @option{none} is selected, no pairwise analysis is performed.

@item statistic = [correlation|compensation|cosubstitutions]
The coevolution statistic to use.
The @option{correlation} option is to be used in order to perform the MBE 2005 analysis.
Uses option @option{compensation} to perform a pairwise analysis with the compensation statistics introduced in the BMC Evol Biol 2007 paper.
You can also use the @option{cosubstitution} option to perform Tuffery & Darlu's MBE 2000 analysis.

@item statistic.output.file = [path]
Where to write the statistic value for each pair of sites.

@item statistic.null = [boolean]
Tell is the null distribution of the statistic must be computed, using
parametric bootstrap.
The number of simulations performed is the product of two numbers,
adjusting the amount of CPU and RAM to use.

@item statistic.null.nb_rep_CPU = [int>0]
Increase this parameter to take less memory (slow the program)

@item statistic.null.nb_rep_RAM = [int>0]
Increase this parameter to speed the program (need more memory)

@item statistic.null.output_file = [path]
Where to write the null distribution

@end table

@section Performing inter-gene comparisons

It is possible to compare all sites from one data set with all sites
from a second data set (inter-gene analysis).

@table @command

@item sequence.file2 = [[path]|none]
The path toward the second file. 
All previous options can be set up for second file, just append '2' at option names.
The default is to use options of file1 for file2.

@end table

@section Optional commands

@table @command
@item statistic.min = [float]
Write only pairs with a statistic greater or equal to this value.

@item statistic.min_rate = [float>0]
Write only pairs with a posterior rate greater or equal to this value.

@item statistic.min_rate_class = [int>0]
Write only pairs with a minimum rate class greater or equal to this
value (first class is 0).

@item statistic.max_rate_diff = [float]
Write only pairs with rates that do not differ more than this value  (-1 ->
write all pairs).

@item statistic.max_rate_class_diff = [int]
Write only pairs with rate classes that do not differ more than this
value (-1 -> write all pairs).

@item statistic.null.cumul = [bool]
[deprecated] Tell if an histogram of the distribution should be returned instead of
printing all simulated pairs.

@item statistic.null.lower = [float]
[deprecated] Lower bound of histogram.

@item statistic.null.upper = [float]
[deprecated] Upper bound of histogram.

@item statistic.null.nb_int = [int<0]
[deprecated] Number of intervals in histogram.

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Clustering, Candidates, Pairwise, Top
@chapter Clustering analysis

@table @command

@item analysis = clustering
Use this option for performing a clustering.
If another option or @option{none} is selected, no pairwise analysis is performed.

@item clustering.distance = [cor|euclidian|comp|none]
Distance to use: cor (correlation), euclidian, comp (compensation) or none (no clustering).

@item clustering.scale = [boolean]
Tell is mapping should be normalized (each row (=branch) will be
divided by its sum.

@item clustering.method = [complete]
Clustering algorithm: complete linkage. Other linkage types are available, but the complete one gives the better results.

@item clustering.output.matrix.file = [[path]|none]
Where to write the distance matrix (in phylip format).

@item clustering.output.tree.file = [[path]|none]
Where to write the clustering tree (newick format).

@item clustering.output.groups.file = [[path]|none]
Where to write the clusters (CSV format).

@item clustering.null = [boolean]
Tell if the null distribution of clusters must be computed.

@item clustering.null.number = [int>0]
Number of data sets to simulate.

@item clustering.null.output.file = [path]
Where to write the simulated clusters (CSV format).

@end table

@c ------------------------------------------------------------------------------------------------------------------

@node Candidates, Pvalue, Clustering, Top
@chapter Candidate groups analysis

This method is under development and is not yet available, sorry.

@c ------------------------------------------------------------------------------------------------------------------

@node Pvalue,  , Candidates, Top
@chapter P-value computation

CoMap do not compute p-values from the simulation.
This goal is achieved by two R scripts, distributed along with the
program.
The script @file{CoMapFunctions.R} contains several functions
performing the computation.
The script @file{computePValues.R} is the one to launch.
It calls the previous one, so they must be in the same directory.

Edit the first section of the @file{computePValues.R} so that is
matches your files, and then run it with the command
@cartouche
@example
R --vanilla < computePValues.R
@end example
@end cartouche

@c ------------------------------------------------------------------------------------------------------------------


@c ------------------------------------------------------------------------------------------------------------------
@c end of document

@c @node Index,  , Pvalue, Top
@c @unnumbered Index
@c
@c @printindex cp

@bye
